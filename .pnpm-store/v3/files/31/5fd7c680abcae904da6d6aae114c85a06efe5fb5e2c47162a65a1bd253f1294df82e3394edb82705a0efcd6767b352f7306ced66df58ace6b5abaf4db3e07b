import { InfiniteData } from '@tanstack/react-query';
import { TRPCClientErrorLike } from '@trpc/client';
import { AnyMutationProcedure, AnyProcedure, AnyQueryProcedure, AnyRouter, AnySubscriptionProcedure, ProcedureRouterRecord, inferProcedureInput, inferProcedureOutput } from '@trpc/server';
import { inferObservableValue } from '@trpc/server/observable';
import { CreateReactUtilsProxy } from './shared';
import { CreateClient, CreateReactQueryHooks, TRPCProvider, UseDehydratedState, UseTRPCInfiniteQueryOptions, UseTRPCInfiniteQueryResult, UseTRPCInfiniteQuerySuccessResult, UseTRPCMutationOptions, UseTRPCMutationResult, UseTRPCQueryOptions, UseTRPCQueryResult, UseTRPCQuerySuccessResult, UseTRPCSubscriptionOptions } from './shared/hooks/createHooksInternal';
import { CreateTRPCReactOptions } from './shared/types';
/**
 * @internal
 */
export declare type DecorateProcedure<TProcedure extends AnyProcedure, TFlags, TPath extends string> = TProcedure extends AnyQueryProcedure ? {
    useQuery: <TQueryFnData = inferProcedureOutput<TProcedure>, TData = inferProcedureOutput<TProcedure>>(input: inferProcedureInput<TProcedure>, opts?: UseTRPCQueryOptions<TPath, inferProcedureInput<TProcedure>, TQueryFnData, TData, TRPCClientErrorLike<TProcedure>>) => UseTRPCQueryResult<TData, TRPCClientErrorLike<TProcedure>>;
} & (inferProcedureInput<TProcedure> extends {
    cursor?: any;
} ? {
    useInfiniteQuery: <_TQueryFnData = inferProcedureOutput<TProcedure>, TData = inferProcedureOutput<TProcedure>>(input: Omit<inferProcedureInput<TProcedure>, 'cursor'>, opts?: UseTRPCInfiniteQueryOptions<TPath, inferProcedureInput<TProcedure>, TData, TRPCClientErrorLike<TProcedure>>) => UseTRPCInfiniteQueryResult<TData, TRPCClientErrorLike<TProcedure>>;
} & (TFlags extends 'ExperimentalSuspense' ? {
    useSuspenseInfiniteQuery: <_TQueryFnData = inferProcedureOutput<TProcedure>, TData = inferProcedureOutput<TProcedure>>(input: Omit<inferProcedureInput<TProcedure>, 'cursor'>, opts?: Omit<UseTRPCInfiniteQueryOptions<TPath, inferProcedureInput<TProcedure>, TData, TRPCClientErrorLike<TProcedure>>, 'enabled' | 'suspense'>) => [
        InfiniteData<TData>,
        UseTRPCInfiniteQuerySuccessResult<TData, TRPCClientErrorLike<TProcedure>>
    ];
} : {}) : {}) & (TFlags extends 'ExperimentalSuspense' ? {
    useSuspenseQuery: <TQueryFnData = inferProcedureOutput<TProcedure>, TData = inferProcedureOutput<TProcedure>>(input: inferProcedureInput<TProcedure>, opts?: Omit<UseTRPCQueryOptions<TPath, inferProcedureInput<TProcedure>, TQueryFnData, TData, TRPCClientErrorLike<TProcedure>>, 'enabled' | 'suspense'>) => [
        TData,
        UseTRPCQuerySuccessResult<TData, TRPCClientErrorLike<TProcedure>>
    ];
} : {}) : TProcedure extends AnyMutationProcedure ? {
    useMutation: <TContext = unknown>(opts?: UseTRPCMutationOptions<inferProcedureInput<TProcedure>, TRPCClientErrorLike<TProcedure>, inferProcedureOutput<TProcedure>, TContext>) => UseTRPCMutationResult<inferProcedureOutput<TProcedure>, TRPCClientErrorLike<TProcedure>, inferProcedureInput<TProcedure>, TContext>;
} : TProcedure extends AnySubscriptionProcedure ? {
    useSubscription: (input: inferProcedureInput<TProcedure>, opts?: UseTRPCSubscriptionOptions<inferObservableValue<inferProcedureOutput<TProcedure>>, TRPCClientErrorLike<TProcedure>>) => void;
} : never;
/**
 * @internal
 */
export declare type DecoratedProcedureRecord<TProcedures extends ProcedureRouterRecord, TFlags, TPath extends string = ''> = {
    [TKey in keyof TProcedures]: TProcedures[TKey] extends AnyRouter ? DecoratedProcedureRecord<TProcedures[TKey]['_def']['record'], TFlags, `${TPath}${TKey & string}.`> : TProcedures[TKey] extends AnyProcedure ? DecorateProcedure<TProcedures[TKey], TFlags, `${TPath}${TKey & string}`> : never;
};
export declare type CreateTRPCReact<TRouter extends AnyRouter, TSSRContext, TFlags> = {
    useContext(): CreateReactUtilsProxy<TRouter, TSSRContext>;
    Provider: TRPCProvider<TRouter, TSSRContext>;
    createClient: CreateClient<TRouter>;
    useDehydratedState: UseDehydratedState<TRouter>;
} & DecoratedProcedureRecord<TRouter['_def']['record'], TFlags>;
/**
 * @internal
 */
export declare function createHooksInternalProxy<TRouter extends AnyRouter, TSSRContext = unknown, TFlags = null>(trpc: CreateReactQueryHooks<TRouter, TSSRContext>): CreateTRPCReact<TRouter, TSSRContext, TFlags>;
export declare function createTRPCReact<TRouter extends AnyRouter, TSSRContext = unknown, TFlags = null>(opts?: CreateTRPCReactOptions<TRouter>): CreateTRPCReact<TRouter, TSSRContext, TFlags>;
//# sourceMappingURL=createTRPCReact.d.ts.map